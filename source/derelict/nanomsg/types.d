/*

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/
module derelict.nanomsg.types;



/******************************************************************************/
/*  ABI versioning support.                                                   */
/******************************************************************************/

/*  Don't change this unless you know exactly what you're doing and have      */
/*  read and understand the following documents:                              */
/*  www.gnu.org/software/libtool/manual/html_node/Libtool-versioning.html     */
/*  www.gnu.org/software/libtool/manual/html_node/Updating-version-info.html  */

/*  The current interface version. */
enum NN_VERSION_CURRENT = 2;

/*  The latest revision of the current interface. */
enum NN_VERSION_REVISION = 1;

/*  How many past interface versions are still supported. */
enum NN_VERSION_AGE = 2;


/******************************************************************************/
/*  Errors.                                                                   */
/******************************************************************************/

/*  A number random enough not to collide with different errno ranges on      */
/*  different OSes. The assumption is that error_t is at least 32-bit type.   */
enum NN_HAUSNUMERO = 156384712;

/*  On some platforms some standard POSIX errnos are not defined.    */
enum ENOTSUP = (NN_HAUSNUMERO + 1);
enum EPROTONOSUPPORT = (NN_HAUSNUMERO + 2);
enum ENOBUFS = (NN_HAUSNUMERO + 3);
enum ENETDOWN = (NN_HAUSNUMERO + 4);
enum EADDRINUSE = (NN_HAUSNUMERO + 5);
enum EADDRNOTAVAIL = (NN_HAUSNUMERO + 6);
enum ECONNREFUSED = (NN_HAUSNUMERO + 7);
enum EINPROGRESS = (NN_HAUSNUMERO + 8);
enum ENOTSOCK = (NN_HAUSNUMERO + 9);
enum EAFNOSUPPORT = (NN_HAUSNUMERO + 10);
enum EPROTO = (NN_HAUSNUMERO + 11);
enum EAGAIN = (NN_HAUSNUMERO + 12);
enum EBADF = (NN_HAUSNUMERO + 13);
enum EINVAL = (NN_HAUSNUMERO + 14);
enum EMFILE = (NN_HAUSNUMERO + 15);
enum EFAULT = (NN_HAUSNUMERO + 16);
enum EACCES = (NN_HAUSNUMERO + 17);
enum EACCESS = (EACCES);
enum ENETRESET = (NN_HAUSNUMERO + 18);
enum ENETUNREACH = (NN_HAUSNUMERO + 19);
enum EHOSTUNREACH = (NN_HAUSNUMERO + 20);
enum ENOTCONN = (NN_HAUSNUMERO + 21);
enum EMSGSIZE = (NN_HAUSNUMERO + 22);
enum ETIMEDOUT = (NN_HAUSNUMERO + 23);
enum ECONNABORTED = (NN_HAUSNUMERO + 24);
enum ECONNRESET = (NN_HAUSNUMERO + 25);
enum ENOPROTOOPT = (NN_HAUSNUMERO + 26);
enum EISCONN = (NN_HAUSNUMERO + 27);
enum NN_EISCONN_DEFINED = 1;
enum ESOCKTNOSUPPORT = (NN_HAUSNUMERO + 28);

/*  Native nanomsg error codes.                                               */
enum ETERM = (NN_HAUSNUMERO + 53);
enum EFSM = (NN_HAUSNUMERO + 54);


/*  Constants that are returned in `ns` member of nn_symbol_properties        */
enum NN_NS_NAMESPACE = 0;
enum NN_NS_VERSION = 1;
enum NN_NS_DOMAIN = 2;
enum NN_NS_TRANSPORT = 3;
enum NN_NS_PROTOCOL = 4;
enum NN_NS_OPTION_LEVEL = 5;
enum NN_NS_SOCKET_OPTION = 6;
enum NN_NS_TRANSPORT_OPTION = 7;
enum NN_NS_OPTION_TYPE = 8;
enum NN_NS_OPTION_UNIT = 9;
enum NN_NS_FLAG = 10;
enum NN_NS_ERROR = 11;
enum NN_NS_LIMIT = 12;

/*  Constants that are returned in `type` member of nn_symbol_properties      */
enum NN_TYPE_NONE = 0;
enum NN_TYPE_INT = 1;
enum NN_TYPE_STR = 2;

/*  Constants that are returned in the `unit` member of nn_symbol_properties  */
enum NN_UNIT_NONE = 0;
enum NN_UNIT_BYTES = 1;
enum NN_UNIT_MILLISECONDS = 2;
enum NN_UNIT_PRIORITY = 3;
enum NN_UNIT_BOOLEAN = 4;

/*  Structure that is returned from nn_symbol  */
struct nn_symbol_properties {

	/*  The constant value  */
	int value;

	/*  The constant name  */
	const char* name;

	/*  The constant namespace, or zero for namespaces themselves */
	int ns;

	/*  The option type for socket option constants  */
	int type;

	/*  The unit for the option value for socket option constants  */
	int unit;
};

/******************************************************************************/
/*  Zero-copy support.                                                        */
/******************************************************************************/

enum NN_MSG = cast(size_t)(-1);


/******************************************************************************/
/*  Socket definition.                                                        */
/******************************************************************************/

struct nn_iovec {
	void* iov_base;
	size_t iov_len;
};

struct nn_msghdr {
	nn_iovec* msg_iov;
	int msg_iovlen;
	void* msg_control;
	size_t msg_controllen;
};

struct nn_cmsghdr {
	size_t cmsg_len;
	int cmsg_level;
	int cmsg_type;
};

/*  SP address families.                                                      */
enum AF_SP = 1;
enum AF_SP_RAW = 2;

/*  Max size of an SP address.                                                */
enum NN_SOCKADDR_MAX = 128;

/*  Socket option levels: Negative numbers are reserved for transports,
    positive for socket types. */
enum NN_SOL_SOCKET = 0;

/*  Generic socket options (NN_SOL_SOCKET level).                             */
enum NN_LINGER = 1;
enum NN_SNDBUF = 2;
enum NN_RCVBUF = 3;
enum NN_SNDTIMEO = 4;
enum NN_RCVTIMEO = 5;
enum NN_RECONNECT_IVL = 6;
enum NN_RECONNECT_IVL_MAX = 7;
enum NN_SNDPRIO = 8;
enum NN_RCVPRIO = 9;
enum NN_SNDFD = 10;
enum NN_RCVFD = 11;
enum NN_DOMAIN = 12;
enum NN_PROTOCOL = 13;
enum NN_IPV4ONLY = 14;
enum NN_SOCKET_NAME = 15;

/*  Send/recv options.                                                        */
enum NN_DONTWAIT = 1;

/*  Ancillary data.                                                           */
enum PROTO_SP = 1;
enum SP_HDR = 1;

/******************************************************************************/
/*  Socket mutliplexing support.                                              */
/******************************************************************************/

enum NN_POLLIN = 1;
enum NN_POLLOUT = 2;

struct nn_pollfd {
	int fd;
	short events;
	short revents;
};





/*****************/
/* Pair          */
/*****************/
enum NN_PROTO_PAIR = 1;
enum NN_PAIR = (NN_PROTO_PAIR * 16 + 0);

/*****************/
/* Pubsub        */
/*****************/
enum NN_PROTO_PUBSUB = 2;
enum NN_PUB = (NN_PROTO_PUBSUB * 16 + 0);
enum NN_SUB = (NN_PROTO_PUBSUB * 16 + 1);
enum NN_SUB_SUBSCRIBE = 1;
enum NN_SUB_UNSUBSCRIBE = 2;

/*****************/
/* ReqRep        */
/*****************/
enum NN_PROTO_REQREP = 3;
enum NN_REQ = (NN_PROTO_REQREP * 16 + 0);
enum NN_REP = (NN_PROTO_REQREP * 16 + 1);
enum NN_REQ_RESEND_IVL = 1;

/*****************/
/* Pipeline      */
/*****************/
enum NN_PROTO_PIPELINE = 5;
enum NN_PUSH = (NN_PROTO_PIPELINE * 16 + 0);
enum NN_PULL= (NN_PROTO_PIPELINE * 16 + 1);

/*****************/
/* Survey        */
/*****************/
enum NN_PROTO_SURVEY = 6;
enum NN_SURVEYOR = (NN_PROTO_SURVEY * 16 + 0);
enum NN_RESPONDENT = (NN_PROTO_SURVEY * 16 + 1);
enum NN_SURVEYOR_DEADLINE = 1;

/*****************/
/* Bus           */
/*****************/
enum NN_PROTO_BUS = 7;
enum NN_BUS = (NN_PROTO_BUS * 16 + 0);






/*****************/
/* Inproc        */
/*****************/
enum NN_INPROC = -1;

/*****************/
/* Ipc           */
/*****************/
enum NN_IPC = -2;

/*****************/
/* Tcp           */
/*****************/
enum NN_TCP = -3;
enum NN_TCP_NODELAY = 1;